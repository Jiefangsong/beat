#!/usr/bin/env python

import sys, re, os, logging, copy
from optparse import OptionParser

from beat import heart, config, utility, models, inputf

from pyrocko import model, util

from pyrocko.guts import load


logger = logging.getLogger('beat')

def d2u(d):
    return dict((k.replace('-','_'), v) for (k, v) in d.iteritems())

subcommand_descriptions = {
        'init':           'create a new EQ model project',
        'import_data':    'import data from external format',
        'sample':         'sample the solution space of the problem',
        'build_gfs':      'build GF stores',
        'plot':           'plot specified setups or results'
    }

#        'sample_slip_s':    'sample static pdf',
#        'roll_slip_k':    'sample kinematic pdf',
#        'plot':           'plot output of any previous step',
#    }

subcommand_usages = {
        'init':          'init <event_name> <event_date "YYYY-MM-DD"> '
                         '[options]',
        'import_data':   'import_data <event_name> [options]',
        'sample':        'sample <event_name> [options]',
        'build_gfs':     'build <event_name> [options]',
        'plot':          'plot <event_name> <mode>',
    }

subcommands = subcommand_descriptions.keys()

program_name = 'beat'

usage = program_name + ''' <subcommand> <arguments> ... [options]

Subcommands:

    init            %(init)s
    import_data     %(import_data)s
    sample          %(sample)s
    build_gfs       %(build_gfs)s


To get further help and a list of available options for any subcommand run:

    beat <subcommand> --help

''' % d2u(subcommand_descriptions)


def add_common_options(parser):
    parser.add_option('--loglevel',
        action = 'store',
        dest = 'loglevel',
        type = 'choice',
        choices = ('critical', 'error', 'warning', 'info', 'debug'),
        default = 'info',
        help ='set logger level to '
              '"critical", "error", "warning", "info", or "debug". '
              'Default is "%default".')

def process_common_options(options):
    utility.setup_logging(options.main_path, options.loglevel)

def die(message, err=''):
    sys.exit('%s: error: %s \n %s' % (program_name, message, err))


def cl_parse(command, args, setup=None, details=None):
    usage = subcommand_usages[command]
    descr = subcommand_descriptions[command]

    if isinstance(usage, basestring):
        usage = [usage]

    susage = '%s %s' % (program_name, usage[0])
    for s in usage[1:]:
        susage += '\n%s%s %s' % (' '*7, program_name, s)

    description = descr[0].upper() + descr[1:] + '.'

    if details:
        description = description + ' %s' % details

    parser = OptionParser(usage=susage, description=description)

    if setup:
        setup(parser)

    add_common_options(parser)
    (options, args) = parser.parse_args(args)
    process_common_options(options)
    return parser, options, args


def load_config(fn):
    try:
        config = load(filename=fn)
        assert isinstance(config, config.BEATconfig)

    except:
        die('cannot load BEAT config from file: %s' % fn)

    return config


def command_init(args):

    def setup(parser):
        def list_callback(option, opt, value, parser):
            out = [ival.lstrip() for ival in value.split(',')]
            setattr(parser.values, option.dest, out)

        parser.add_option('--min_mag', dest='min_mag', type=float,
                default=6.,
                help='Minimum Mw for event, for catalog search.'
                     ' Default: "6.0"')

        parser.add_option('--main_path', dest='main_path', type='string',
                default='./',
                help='Main path (absolute) for creating directory structure.'
                     '  Default: current directory ./')

        parser.add_option('--datasets',
                default='geodetic', type='string',
                action='callback', callback=list_callback,
                help='Datasets to include in the setup; "geodetic, seismic".'
                     ' Default: "geometry"')

        parser.add_option('--mode', dest='mode',
                choices=['geometry', 'static_dist', 'kinemtic_dist'],
                default='geometry',
                help='Inversion problem to solve; "geometry", "static_dist",'
                     '"kinematic_dist". Default: "geometry"')

        parser.add_option('--n_variations', dest='n_variations', type='int',
                metavar='N', default=0,
                help='Number of velocity models to vary the reference model.'
                     ' Default: 0')

        parser.add_option('--n_faults', dest='n_faults', type='int',
                default=1,
                help='Integer Number of faults to invert for. Default: 1' )

        parser.add_option('--sampler', dest='sampler', type='string',
                default='ATMCMC',
                help='Sampling algoruthm to sample the solution space;'
                     '"ATMCMC", "Metropolis". Default: "ATMCMC"')

    parser, options, args = cl_parse('init', args, setup=setup)

    if len(args) != 2:
        logger.error('Wrong number of input arguments!')
        parser.print_help()
        sys.exit(1)

    name, date = args

    return config.init_config(name, date,
               min_magnitude=options.min_mag,
               main_path=options.main_path,
               datasets=options.datasets,
               mode=options.mode,
               n_variations=options.n_variations,
               n_faults=options.n_faults,
               sampler=options.sampler)

def command_import_data(args):

    def setup(parser):

        parser.add_option('--main_path', dest='main_path', type='string',
                default='./',
                help='Main path (absolute) leading to folders of events that'
                     ' have been created by "init".'
                     ' Default: current directory: ./')

        parser.add_option('--geodetic_format', dest='geodetic_format',
                type='string', default='matlab',
                help='Data format to be imported; "matlab", ...,'
                     ' Default: "matlab"')

        parser.add_option('--seismic_format', dest='seismic_format',
                type='string', default='autokiwi',
                help='Data format to be imported; "autokiwi", ...,'
                     'Default: "autokiwi"')

        parser.add_option('--mode', dest='mode',
                choices=['geometry', 'static_dist', 'kinemtic_dist'],
                default='geometry',
                help='Inversion problem to solve; "geometry", "static_dist",'
                     '"kinematic_dist". Default: "geometry"')

    parser, options, args = cl_parse('import_data', args, setup=setup)

    try:
        name = args.pop()
    except:
        parser.error('cannot get <event_name> argument')
        parser.print_help()

    main_path = os.getcwd()
    project_dir = os.path.join(main_path, name)

    c = config.load_config(project_dir, options.mode)

    pc = c.problem_config

    if 'seismic' in pc.datasets:
        sc = c.seismic_config
        logger.info('Importing seismic data from %s' % sc.datadir)

        if options.seismic_format == 'autokiwi':

            stations = model.load_stations(
                os.path.join(sc.datadir,'stations.txt'))

            data_traces = inputf.load_data_traces(
                datadir=sc.datadir,
                stations=stations,
                channels=sc.channels)

            seismic_outpath = os.path.join(
                c.project_dir, config.seismic_data_name)

            logger.info('Pickle seismic data to %s' % seismic_outpath)
            utility.dump_objects(seismic_outpath,
                outlist=[stations, data_traces])

        else:
            raise Exception(
                'Format: %s not implemented yet.' % options.seismic_format)

    if 'geodetic' in pc.datasets:
        gc = c.geodetic_config
        logger.info('Importing geodetic data from %s' % gc.datadir)

        if options.geodetic_format == 'matlab':
            gtargets = inputf.load_SAR_data(gc.datadir, gc.tracks)

            geodetic_outpath = os.path.join(
                c.project_dir, config.geodetic_data_name)

            logger.info('Pickle geodetic data to %s' % geodetic_outpath)
            utility.dump_objects(geodetic_outpath, outlist=[gtargets])
        else:
            raise Exception(
                'Format: %s not implemented yet.' % options.geodetic_format)


def command_sample(args):

    def setup(parser):
        parser.add_option('--mode', dest='mode',
                choices=['geometry', 'static_dist', 'kinemtic_dist'],
                default='geometry',
                help='Inversion problem to solve; "geometry", "static_dist",'
                     '"kinematic_dist". Default: "geometry"')

        parser.add_option('--main_path', dest='main_path', type='string',
                default='./',
                help='Main path (absolute) leading to folders of events that'
                     ' have been created by "init".'
                     ' Default: current directory: ./')

    parser, options, args = cl_parse('sample', args, setup=setup)

    try:
        name = args.pop()
    except:
        parser.error('cannot get <event_name> argument')
        parser.print_help()

    os.chdir(options.main_path)
    main_path = os.getcwd()
    project_dir = os.path.join(main_path, name)

    problem = models.load_model(project_dir, options.mode)

    step = problem.init_sampler()

    models.sample(step, problem)


def command_build_geo_gfs(config):

    config_fn = os.path.join(project_dir, 'config')
    config = model.load(filename=config_fn)

    eventname = os.path.join(config.seismic_datadir, 'event.txt')
    event = model.load_one_event(eventname)

    for crust_ind in config.crust_inds:
        heart.geo_construct_gf(event, store_superdir,
                     source_distance_min=0., source_distance_max=100.,
                     source_depth_min=0., source_depth_max=50.,
                     source_spacing=0.5, earth_model='ak135-f-average.m',
                     crust_ind=crust_ind, execute=True)


if __name__ == '__main__':

    usage_sub = 'BEAT %s [options]'
    if len(sys.argv) < 2:
        sys.exit('Usage: %s' % usage)

    args = list(sys.argv)
    args.pop(0)
    command = args.pop(0)

    if command in subcommands:
        globals()['command_'+ command](args)

    elif command in ('--help', '-h', 'help'):
        if command == 'help' and args:
            acommand = args[0]
            if acommand in subcommands:
                globals()['command_'+ acommand]([ '--help' ] )

        sys.exit('Usage: %s' % usage)

    else:
        sys.exit('BEAT: error: no such subcommand: %s' % command)

