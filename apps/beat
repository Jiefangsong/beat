#!/usr/bin/env python

import sys, re, os, logging, copy
from optparse import OptionParser

from beat import heart, config, utility, models, inputf

from pyrocko import model, util

from pyrocko.guts import load


logger = logging.getLogger('beat')

def d2u(d):
    return dict((k.replace('-','_'), v) for (k, v) in d.iteritems())

subcommand_descriptions = {
        'init':           'create a new EQ model project',
        'import_data':    'import data from external format',
        'sample':         'sample the solution space of the problem',
        'build_gfs':      'build GF stores',
        'plot':           'plot specified setups or results'
    }

#        'sample_slip_s':    'sample static pdf',
#        'roll_slip_k':    'sample kinematic pdf',
#        'plot':           'plot output of any previous step',
#    }

subcommand_usages = {
        'init':          'init <event_name> <event_date "YYYY-MM-DD"> '
                         '[options]',
        'import_data':   'import_data <event_name> [options]',
        'sample':        'sample <event_name> [options]',
        'build_gfs':     'build <event_name> [options]',
        'plot':          'plot <event_name> <mode>',
    }

subcommands = subcommand_descriptions.keys()

program_name = 'beat'

usage = program_name + ''' <subcommand> <arguments> ... [options]
BEAT: Bayesian earthquake analysis tool
 Version 0.1
author: Hannes Vasyuara-Bathke
email: hannes.vasyura-bathke@kaust.edu.sa

Subcommands:

    init            %(init)s
    import_data     %(import_data)s
    build_gfs       %(build_gfs)s
    sample          %(sample)s


To get further help and a list of available options for any subcommand run:

    beat <subcommand> --help

''' % d2u(subcommand_descriptions)


def add_common_options(parser):
    parser.add_option('--loglevel',
        action = 'store',
        dest = 'loglevel',
        type = 'choice',
        choices = ('critical', 'error', 'warning', 'info', 'debug'),
        default = 'info',
        help ='set logger level to '
              '"critical", "error", "warning", "info", or "debug". '
              'Default is "%default".')


def process_common_options(options, name):
    project_dir = os.path.join(options.main_path, name)
    util.ensuredir(project_dir)
    utility.setup_logging(project_dir, options.loglevel)


def die(message, err=''):
    sys.exit('%s: error: %s \n %s' % (program_name, message, err))


def cl_parse(command, args, setup=None, details=None):
    usage = subcommand_usages[command]
    descr = subcommand_descriptions[command]

    if isinstance(usage, basestring):
        usage = [usage]

    susage = '%s %s' % (program_name, usage[0])
    for s in usage[1:]:
        susage += '\n%s%s %s' % (' '*7, program_name, s)

    description = descr[0].upper() + descr[1:] + '.'

    if details:
        description = description + ' %s' % details

    parser = OptionParser(usage=susage, description=description)

    if setup:
        setup(parser)

    add_common_options(parser)
    (options, args) = parser.parse_args(args)
    process_common_options(options, name=args[0])
    return parser, options, args


def load_config(fn):
    try:
        config = load(filename=fn)
        assert isinstance(config, config.BEATconfig)

    except:
        die('cannot load BEAT config from file: %s' % fn)

    return config


def command_init(args):

    def setup(parser):
        def list_callback(option, opt, value, parser):
            out = [ival.lstrip() for ival in value.split(',')]
            setattr(parser.values, option.dest, out)

        parser.add_option('--min_mag', dest='min_mag', type=float,
            default=6.,
            help='Minimum Mw for event, for catalog search.'
                 ' Default: "6.0"')

        parser.add_option('--main_path', dest='main_path', type='string',
            default='./',
            help='Main path (absolute) for creating directory structure.'
                 '  Default: current directory ./')

        parser.add_option('--datasets',
            default=['geodetic'], type='string',
            action='callback', callback=list_callback,
            help='Datasets to include in the setup; "geodetic, seismic".')

        parser.add_option('--mode', dest='mode',
            choices=['geometry', 'static_dist', 'kinemtic_dist'],
            default='geometry',
            help='Inversion problem to solve; "geometry", "static_dist",'
                 '"kinematic_dist". Default: "geometry"')

        parser.add_option('--n_faults', dest='n_faults', type='int',
            default=1,
            help='Integer Number of faults to invert for. Default: 1' )

        parser.add_option('--sampler', dest='sampler', type='string',
            default='ATMCMC',
            help='Sampling algoruthm to sample the solution space;'
                 '"ATMCMC", "Metropolis". Default: "ATMCMC"')

        parser.add_option('--use_custom', dest='use_custom',
            action='store_true',
            help='If set, a slot for a custom velocity model is being created'
                 ' in the configuration file.')

    parser, options, args = cl_parse('init', args, setup=setup)

    if len(args) != 2:
        logger.error('Wrong number of input arguments!')
        parser.print_help()
        sys.exit(1)

    name, date = args

    return config.init_config(name, date,
               min_magnitude=options.min_mag,
               main_path=options.main_path,
               datasets=options.datasets,
               mode=options.mode,
               n_faults=options.n_faults,
               sampler=options.sampler,
               use_custom=options.use_custom)


def command_import_data(args):

    def setup(parser):
        def list_callback(option, opt, value, parser):
            out = [ival.lstrip() for ival in value.split(',')]
            setattr(parser.values, option.dest, out)

        parser.add_option('--main_path', dest='main_path', type='string',
            default='./',
            help='Main path (absolute) leading to folders of events that'
                 ' have been created by "init".'
                 ' Default: current directory: ./')

        parser.add_option('--datasets',
            default=['geodetic'], type='string',
            action='callback', callback=list_callback,
            help='Datasets to import; "geodetic, seismic".')

        parser.add_option('--geodetic_format', dest='geodetic_format',
            type='string', default='matlab',
            help='Data format to be imported; "matlab", ...,'
                 ' Default: "matlab"')

        parser.add_option('--seismic_format', dest='seismic_format',
            type='string', default='autokiwi',
            help='Data format to be imported; "autokiwi", ...,'
                 'Default: "autokiwi"')

        parser.add_option('--mode', dest='mode',
            choices=['geometry', 'static_dist', 'kinemtic_dist'],
            default='geometry',
            help='Inversion problem to solve; "geometry", "static_dist",'
                 '"kinematic_dist". Default: "geometry"')

    parser, options, args = cl_parse('import_data', args, setup=setup)

    try:
        name = args.pop()
    except:
        parser.error('cannot get <event_name> argument')
        parser.print_help()

    main_path = os.getcwd()
    project_dir = os.path.join(main_path, name)

    c = config.load_config(project_dir, options.mode)

    pc = c.problem_config

    if 'seismic' in options.datasets:
        sc = c.seismic_config
        logger.info('Importing seismic data from %s' % sc.datadir)

        if options.seismic_format == 'autokiwi':

            stations = model.load_stations(
                os.path.join(sc.datadir,'stations.txt'))

            data_traces = inputf.load_data_traces(
                datadir=sc.datadir,
                stations=stations,
                channels=sc.channels)

            seismic_outpath = os.path.join(
                c.project_dir, config.seismic_data_name)

            logger.info('Pickle seismic data to %s' % seismic_outpath)
            utility.dump_objects(seismic_outpath,
                outlist=[stations, data_traces])

        else:
            raise Exception(
                'Format: %s not implemented yet.' % options.seismic_format)

    if 'geodetic' in options.datasets:
        gc = c.geodetic_config
        logger.info('Importing geodetic data from %s' % gc.datadir)

        if options.geodetic_format == 'matlab':
            gtargets = inputf.load_SAR_data(gc.datadir, gc.tracks)

            geodetic_outpath = os.path.join(
                c.project_dir, config.geodetic_data_name)

            logger.info('Pickle geodetic data to %s' % geodetic_outpath)
            utility.dump_objects(geodetic_outpath, outlist=gtargets)
        else:
            raise Exception(
                'Format: %s not implemented yet.' % options.geodetic_format)


def command_sample(args):

    def setup(parser):
        parser.add_option('--mode', dest='mode',
            choices=['geometry', 'static_dist', 'kinemtic_dist'],
            default='geometry',
            help='Inversion problem to solve; "geometry", "static_dist",'
                 '"kinematic_dist". Default: "geometry"')

        parser.add_option('--main_path', dest='main_path', type='string',
            default='./',
            help='Main path (absolute) leading to folders of events that'
                 ' have been created by "init".'
                 ' Default: current directory: ./')

    parser, options, args = cl_parse('sample', args, setup=setup)

    try:
        name = args.pop()
    except:
        parser.error('cannot get <event_name> argument')
        parser.print_help()

    os.chdir(options.main_path)
    main_path = os.getcwd()
    project_dir = os.path.join(main_path, name)

    problem = models.load_model(project_dir, options.mode)

    step = problem.init_sampler()

    models.sample(step, problem)


def command_build_gfs(args):

    def setup(parser):
        def list_callback(option, opt, value, parser):
            out = [ival.lstrip() for ival in value.split(',')]
            setattr(parser.values, option.dest, out)

        parser.add_option('--main_path', dest='main_path', type='string',
            default='./',
            help='Main path (absolute) leading to folders of events that'
                 ' have been created by "init".'
                 ' Default: current directory: ./')

        parser.add_option('--mode', dest='mode',
            choices=['geometry', 'static_dist', 'kinemtic_dist'],
            default='geometry',
            help='Inversion problem to calculate GFs for; "geometry",'
                 '"static_dist", "kinematic_dist". Default: "geometry"')

        parser.add_option('--datasets',
            default='geodetic', type='string',
            action='callback', callback=list_callback,
            help='Datasets to calculate the GFs for; "geodetic, seismic".'
                 ' Default: "geodetic"')

        parser.add_option('--force', dest='force', action='store_true',
                help='Overwrite existing files')

        parser.add_option('--execute', dest='execute', action='store_true',
                help='Start actual GF calculations. If not set only'
                     ' configuration files are being created')

    parser, options, args = cl_parse('build_gfs', args, setup=setup)

    try:
        name = args.pop()
    except:
        parser.error('cannot get <event_name> argument')
        parser.print_help()

    main_path = os.getcwd()
    project_dir = os.path.join(main_path, name)

    c = config.load_config(project_dir, options.mode)

    if 'geodetic' in options.datasets:
        gf = c.geodetic_config.gf_config

        for crust_ind in range(gf.n_variations + 1):
            heart.geo_construct_gf(
                event=c.event,
                store_superdir=gf.store_superdir,
                source_depth_min=gf.source_depth_min,
                source_depth_max=gf.source_depth_max,
                source_depth_spacing=gf.source_depth_spacing,
                source_distance_min=gf.source_distance_min,
                source_distance_max=gf.source_distance_max,
                source_distance_spacing=gf.source_distance_spacing,
                sampling_interval=gf.sampling_interval,
                earth_model=gf.earth_model,
                crust_ind=crust_ind,
                use_crust2=gf.use_crust2,
                custom_velocity_model=gf.custom_velocity_model,
                replace_water=gf.replace_water,
                execute=options.execute,
                force=options.force)

        if options.execute:
            logger.info('Geodetic GF calculations successful!')

    if 'seismic' in options.datasets:
        sc = c.seismic_config
        sf = sc.gf_config

        seismic_data_path = os.path.join(
            c.project_dir, config.seismic_data_name)

        stations, data_traces = utility.load_objects(seismic_data_path)
        stations = utility.apply_station_blacklist(stations, sc.blacklist)

        for crust_ind in range(sf.n_variations + 1):
            for station in stations:
                heart.seis_construct_gf(
                    station=station,
                    event=c.event,
                    store_superdir=sf.store_superdir,
                    code=sf.code,
                    source_depth_min=sf.source_depth_min,
                    source_depth_max=sf.source_depth_max,
                    source_depth_spacing=sf.source_depth_spacing,
                    sample_rate=sf.sample_rate,
                    source_distance_radius=sf.source_distance_radius,
                    source_distance_spacing=sf.source_distance_spacing,
                    depth_limit_variation=sf.depth_limit_variation,
                    earth_model=sf.earth_model,
                    crust_ind=crust_ind,
                    use_crust2=sf.use_crust2,
                    execute=options.execute,
                    rm_gfs=sf.rm_gfs,
                    nworkers=sf.nworkers,
                    custom_velocity_model=sf.custom_velocity_model,
                    force=options.force)

        if not options.execute:
            logger.info('Seismic GF store configs successfully created! '
                        'To start calculations set e')

        if options.execute:
            logger.info('Seismic GF calculations successful!')

if __name__ == '__main__':

    usage_sub = 'BEAT %s [options]'
    if len(sys.argv) < 2:
        sys.exit('Usage: %s' % usage)

    args = list(sys.argv)
    args.pop(0)
    command = args.pop(0)

    if command in subcommands:
        globals()['command_'+ command](args)

    elif command in ('--help', '-h', 'help'):
        if command == 'help' and args:
            acommand = args[0]
            if acommand in subcommands:
                globals()['command_'+ acommand]([ '--help' ] )

        sys.exit('Usage: %s' % usage)

    else:
        sys.exit('BEAT: error: no such subcommand: %s' % command)

